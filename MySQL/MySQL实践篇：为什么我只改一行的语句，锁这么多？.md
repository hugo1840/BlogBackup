@[TOC](为什么我只改一行的语句，锁这么多？)

因为间隙锁在可重复读隔离级别下才有效，所以本篇文章接下来的描述，若没有特殊说明，默认是**可重复读**隔离级别。丁奇老师总结的加锁规则里面，包含了==两个“原则”、两个“优化”和一个“bug”==。

 - 原则 1：加锁的基本单位是 **next-key lock**。next-key lock 是**前开后闭**区间。
 - 原则 2：查找过程中**访问到的对象**才会加锁。
 - 优化 1：索引上的等值查询，给**唯一索引**加锁的时候，next-key lock **退化为行锁**。
 - 优化 2：索引上的等值查询，向右遍历时且**最后一个值不满足等值条件**的时候，next-key lock **退化为间隙锁**。
 - 一个 bug：唯一索引上的范围查询会访问到**不满足条件的第一个值**为止。

MySQL 后面的版本可能会改变加锁策略，所以这个规则只限于截止到现在的最新版本，即 5.x 系列 <=5.7.24，8.0 系列 <=8.0.13。

以上篇文章的表 t 为例

```sql
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  `d` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `c` (`c`)
) ENGINE=InnoDB;

insert into t values(0,0,0),(5,5,5),
(10,10,10),(15,15,15),(20,20,20),(25,25,25);
```


# 案例一：等值查询间隙锁
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/390d63b442f273d44b871c4a8a8386ed.png#pic_center)
由于表 t 中没有 id=7 的记录，所以用我们上面提到的加锁规则判断一下的话：

 - 根据原则 1，**加锁单位是 next-key lock**，session A 加锁范围就是 **(5,10]**；
 - 同时根据优化 2，这是一个等值查询 (id=7)，而 id=10 不满足查询条件，next-key lock 退化成间隙锁，因此最终加锁的范围是 **(5,10)**。

所以，session B 要往这个间隙里面插入 id=8 的记录会被锁住，但是 session C 修改 id=10 这行是可以的。

# 案例二：非唯一索引等值锁
第二个例子是关于覆盖索引上的锁：
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/5e4d65950ee82beae296d67788b3273f.png#pic_center)
这里 session A 要给索引 c 上 c=5 的这一行加上读锁。

 - 根据原则 1，加锁单位是 next-key lock，因此会给 **(0,5]** 加上 next-key lock。
 - 要注意 c 是普通索引，因此仅访问 c=5 这一条记录是不能马上停下来的，需要向右遍历，查到 c=10 才放弃。根据原则 2，**访问到的都要加锁**，因此要给 **(5,10]** 加 next-key lock。
 - 但是同时这个符合优化 2：等值判断，向右遍历，最后一个值不满足 c=5 这个等值条件，因此**退化成间隙锁 (5,10)**。
 - 根据原则 2 ，只有访问到的对象才会加锁，这个查询使用覆盖索引，并**不需要访问主键索引**，所以主键索引上没有加任何锁，这就是为什么 session B 的 update 语句可以执行完成。

但 session C 要插入一个 (7,7,7) 的记录，就会被 session A 的间隙锁 (5,10) 锁住。

在这个例子中，`lock in share mode` **只锁覆盖索引**，但是如果是 for update 就不一样了。 执行 `for update` 时，系统会认为你接下来要更新数据，因此会顺便给**主键索引**上满足条件的行加上行锁（主键索引里存放了整行的数据，因此锁主键即是给整行加锁）。

这个例子说明，**锁是加在索引上的**；同时，它给我们的指导是，如果你要用 `lock in share mode` 来给行加读锁避免数据被更新的话，就**必须得绕过覆盖索引的优化**（由于索引覆盖未访问主键索引，导致只给普通索引加锁，即只给普通索引对应的列加锁），在查询字段中加入索引中不存在的字段。比如，将 session A 的查询语句改成 `select d from t where c=5 lock in share mode`（此时 session B 的更新操作会被锁住）。



# 案例三：主键索引范围锁
对于表 t，考虑下面两条查询语句

```sql
mysql> select * from t where id=10 for update;
mysql> select * from t where id>=10 and id<11 for update;
```

在逻辑上，这两条查语句肯定是等价的，但是它们的加锁规则不太一样。
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/506250eefd3034eb2780dc7ee8df2c25.png#pic_center)
用前面提到的加锁规则，来分析一下 session A 会加什么锁呢？

 - 开始执行的时候，要找到第一个 id=10 的行，因此本该是 next-key lock (5,10]。 根据优化 1， 主键 id 上的等值条件，**退化成行锁**，只加了 **id=10** 这一行的行锁。
 - 范围查找就往后继续找，找到 id=15 这一行停下来，因此需要加 next-key lock **(10,15]**。
 
 所以，session A 这时候锁的范围就是主键索引上，行锁 id=10 和 next-key lock (10,15]。这样，session B 和 session C 的结果你就能理解了。这里你需要注意一点，首次 session A 定位查找 id=10 的行的时候，是当做**等值查询**来判断的，而向右扫描到 id=15 的时候，用的是**范围查询**判断。


# 案例四：非唯一索引范围锁
再来看两个范围查询加锁的例子。与案例三不同的是，案例四中查询语句的 where 部分用的是字段 c。
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/92225467c6d5d4f120ea0a28ee632b5d.png#pic_center)
这次 session A 用字段 c 来判断，加锁规则跟案例三唯一的不同是：在第一次用 c=10 定位记录的时候，索引 c 上加了 (5,10] 这个 next-key lock 后，由于索引 c 是非唯一索引，没有优化规则，也就是说**不会蜕变为行锁**，因此最终 sesion A 加的锁是，索引 c 上的 **(5,10]** 和 **(10,15]** 这两个 next-key lock。

所以从结果上来看，sesson B 要插入（8,8,8) 的这个 insert 语句时就被堵住了。这里需要扫描到 c=15 才停止扫描，是合理的，因为 InnoDB 要扫到 c=15，才知道不需要继续往后找了。


# 案例五：唯一索引范围锁 bug
再看一个关于加锁规则中 bug 的案例。
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/5a9cbd946f6d21382421ffbec63a3c86.png#pic_center)
session A 是一个范围查询，按照原则 1 的话，应该是索引 id 上只加 **(10,15]** 这个 next-key lock，并且因为 id 是唯一键，所以循环判断到 id=15 这一行就应该停止了。

但是实现上，InnoDB 会往前扫描到第一个不满足条件的行为止，也就是 id=20。而且由于这是个范围扫描，因此索引 id 上的 **(15,20]** 这个 next-key lock 也会被锁上。

这里锁住 id=20 这一行的行为，其实是没有必要的。因为扫描到 id=15，就可以确定不用往后再找了。但实现上还是这么做了，因此我认为这是个 bug（MySQL 8 貌似已经解决了这个 bug）。

# 案例六：非唯一索引上存在"等值"的例子

```sql
mysql> insert into t values(30,10,30);
```
新插入的这一行 c=10，也就是说现在表里有两个 c=10 的行。那么，这时候索引 c 上的间隙是什么状态了呢？你要知道，由于非唯一索引上包含主键的值，所以是不可能存在“相同”的两行的。

我们用 delete 语句来验证。注意，delete 语句加锁的逻辑，其实跟 `select ... for update` 是类似的，也就是我在文章开始总结的两个“原则”、两个“优化”和一个“bug”。

![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/21a5da8cd37a358c623e2c12c61b2bda.png#pic_center)
这时，session A 在遍历的时候，先访问第一个 c=10 的记录。同样地，根据原则 1，这里加的是 (c=5,id=5) 到 (c=10,id=10) 这个 next-key lock。

然后，session A 向右查找，直到碰到 (c=15,id=15) 这一行，循环才结束。根据优化 2，这是一个等值查询，向右查找到了不满足条件的行，所以会退化成 (c=10,id=10) 到 (c=15,id=15) 的间隙锁。

也就是说，这个 delete 语句在索引 c 上的加锁范围，就是下图中蓝色区域覆盖的部分。
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/4fb13e0a8359bc5f340a7bf5259fbe0f.png#pic_center)
这个蓝色区域左右两边都是虚线，表示开区间，即 (c=5,id=5) 和 (c=15,id=15) 这两行上都没有锁。


# 案例七：limit 语句加锁
例子 6 也有一个对照案例
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/39799c328e0f5eacf30003121f69ff20.png#pic_center)
session A 的 delete 语句加了 `limit 2`。你知道表 t 里 c=10 的记录其实只有两条，因此加不加 `limit 2`，删除的效果都是一样的，但是加锁的效果却不同。可以看到，session B 的 insert 语句执行通过了，跟案例六的结果不同。

这是因为，案例七里的 delete 语句明确加了 **limit 2** 的限制，因此在遍历到 (c=10, id=30) 这一行之后，满足条件的语句已经有两条，循环就结束了。因此，索引 c 上的加锁范围就变成了从（c=5,id=5) 到（c=10,id=30) 这个前开后闭区间，如下图所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/94f873b2482dd3f54ffd681c349747d8.png#pic_center)
可以看到，(c=10,id=30）之后的这个间隙并没有在加锁范围里，因此 insert 语句插入 c=12 是可以执行成功的。这个例子对我们实践的指导意义就是，**在删除数据的时候尽量加 limit**。这样不仅可以控制删除数据的条数，让操作更安全，还**可以减小加锁的范围**。


# 案例八：一个死锁的例子
再看一个案例，目的是说明：next-key lock 实际上是间隙锁和行锁加起来的结果。
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/7f8106bd487909fb7863e60d99c1cb3a.png#pic_center)

我们按时间顺序来分析一下为什么是这样的结果。

 - session A 启动事务后执行查询语句加 `lock in share mode`，在索引 c 上加了 next-key lock (5,10] 和间隙锁 (10,15)；
 - session B 的 update 语句也要在索引 c 上加 next-key lock (5,10] ，进入锁等待；
 - 然后 session A 要再插入 (8,8,8) 这一行，被 session B 的间隙锁锁住。由于出现了死锁，InnoDB 让 session B 回滚。

但是，session B 的 next-key lock 不是还没申请成功吗？

其实是这样的，session B 的“加 next-key lock(5,10] ”操作，实际上分成了两步，先是加 (5,10) 的**间隙锁**，加锁成功（**间隙锁之间互不冲突**）；然后加 c=10 的**行锁**，这时候才被锁住的（行锁中的**读锁与写锁冲突**）。也就是说，我们在分析加锁规则的时候可以用 next-key lock 来分析。但是要知道，具体执行的时候，是要分成间隙锁和行锁两段来执行的。

# 课堂作业
下面这个图的执行序列中，为什么 session B 的 insert 语句会被堵住。

![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/cf9195b6a6b6baa97df03e62ccb1d536.png#pic_center)

看看 session A 的 select 语句加了哪些锁：

 - 由于是 `order by c desc`，第一个要定位的是索引 c 上“最右边的”c=20 的行，所以会加上间隙锁 **(20,25)** 和 next-key lock **(15,20]**。
 - 在索引 c 上**向左遍历**，要扫描到 c=10 才停下来（原则2：访问到的对象会加锁），所以 next-key lock 会加到 **(5,10]**，这正是阻塞 session B 的 insert 语句的原因。
 - 在扫描过程中，c=20、c=15、c=10 这三行都存在值，由于是 `select *`，所以会在主键 id 上加三个行锁。

因此，session A 的 select 语句锁的范围就是：索引 c 上 **(5, 25)**；主键索引上 **id=15**、**id=20** 两个行锁。

>**Attention**：如果没有关键字 **DESC**，那么第一个要定位的会是索引 c 上“最左边的” c=15，在MySQL 5.7中测试时发现最终加锁的区间不包括 (5,10]，session B 不会被阻塞。


****
**小结**
上面的所有案例都是在可重复读隔离级别 (repeatable-read) 下验证的。同时，可重复读隔离级别遵守两阶段锁协议，所有加锁的资源，都是在事务提交或者回滚的时候才释放的。

在最后的案例中，你可以清楚地知道 next-key lock 实际上是由间隙锁加行锁实现的。如果切换到读提交隔离级别 (read-committed) 的话，就好理解了，过程中去掉间隙锁的部分，也就是只剩下行锁的部分。

其实读提交隔离级别在外键场景下还是有间隙锁，相对比较复杂，我们今天先不展开。另外，在读提交隔离级别下还有一个优化，即：==语句执行过程中加上的行锁，在语句执行完成后，就要把“不满足条件的行”上的行锁直接释放了，不需要等到事务提交==。也就是说，读提交隔离级别下，锁的范围更小，锁的时间更短，这也是不少业务都默认使用读提交隔离级别的原因。
