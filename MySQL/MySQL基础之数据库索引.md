@[TOC](MySQL基础之数据库索引)

# 索引的常见模型
索引可以提高数据库查询的效率。哈希表、有序数组、搜索树是三种常见的可以用于实现索引的数据结构。

## 哈希表
哈希表是一种以**键值对**（key-value）存储数据的结构。哈希表的思路很简单，用一个哈希函数把key转化为一个表示位置的确定值，然后把value放在一个数组中的该位置。但是，多个key经过哈希函数的换算后，可能得到同一个value。此时，就会使用到链表，对value相同的数据（键值对）进行遍历。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210314210651361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlYmFzdGllbjIz,size_16,color_FFFFFF,t_70#pic_center)


哈希表中的数据不是有序的，因此添加数据时会很快，只需要往后追加。但缺点是做区间查询的速度会很慢。综上，哈希表更适用于只有**等值查询**的场景，比如Memcached以及其他一些NoSQL引擎。

## 有序数组
有序数组在等值查询和**范围查询**场景中的性能就非常优秀。在有序数组中进行范围查询时，可以先使用二分法找到范围的左边界，然后向右遍历即可。有序数组的问题在于更新数据比较麻烦，往数组中插入一个记录就必须移动后面的所有记录，成本很高。因此，有序数组只适用于**静态存储引擎**，比如基本不会修改的数据库。

## 搜索树
二叉搜索树也可以用于实现索引。二叉搜索树的特点是：父节点左子树所有结点的值小于父节点的值，右子树所有结点的值大于父节点的值。二叉树是搜索效率最高的（时间复杂度为`O(log(N))`），但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到**磁盘**上。对于一个数据量较大的表，对应的二叉树会很高，每次查询会访问过多的节点，即访问数据块过多，而从磁盘随机读取数据块是很费时的。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210314213705531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlYmFzdGllbjIz,size_16,color_FFFFFF,t_70#pic_center)


为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块，即减少磁盘I/O。因此，就不应该使用二叉树，而是要使用“N叉”树。这里，“N叉”树中的“N”取决于**数据块**的大小。

以 InnoDB 的一个整数字段索引为例（N 大约是 1200），树高为4时，就可以存1200的3次方个值，即17亿。考虑到树根的数据块总是在内存中的，一个10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3次磁盘。

N叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。在 MySQL 中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。


# InnoDB的索引模型
在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为**索引组织表**。InnoDB 使用了 **B+ 树**索引模型，所以数据都是存储在 B+ 树中的。==每一个索引在 InnoDB 中对应一棵 B+ 树==。

> 有关 B+ 树的知识点请参考：https://www.cnblogs.com/nullzx/p/8729425.html

根据**叶节点**的内容，可以将索引分为主键索引和非主键索引。==主键索引的叶节点存的是整行数据==。在 InnoDB 里，主键索引也被称为**聚簇索引**（clustered index）；==非主键索引的叶节点内容是主键的值==。在 InnoDB 里，非主键索引也被称为**二级索引**（secondary index）。

二级索引的叶节点存的就是主键的值，而不是引用！根据这个值进行回表，再在聚簇索引里面直接从叶节点里面拿到值，不需要进行一次IO去磁盘找。为啥存值不存引用（数据在磁盘的地址指针）？因为一旦发生页分裂或者页合并，就得去维护这个地址指针，更麻烦。

举一个例子。假设我们创建了一个同时包含主键索引和普通索引的表：

```sql
mysql> CREATE TABLE T(
id INT PRIMARY KEY, 
k INT NOT NULL, 
name VARCHAR(16),
INDEX (k))engine=InnoDB;
```

 - 如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；
 - 如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为**回表**。

即，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210315165050387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlYmFzdGllbjIz,size_16,color_FFFFFF,t_70#pic_center)


# 索引维护
B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上图为例，如果插入新的行 ID 值为 700，则只需要在 R5 的记录后面追加插入一个新记录。如果新插入的 ID 值为 400，就需要逻辑上挪动后面的数据，空出位置。

如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为**页分裂**。在这种情况下，性能自然会受影响。此外，页分裂操作还会影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做**合并**。合并的过程，可以认为是分裂过程的逆过程。

**自增主键**
自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的：`NOT NULL PRIMARY KEY AUTO_INCREMENT`。插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值。

自增主键的插入数据模式中，每次插入一条新记录，都是**追加**操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。另一方面，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。因此，从性能和存储空间方面考量，自增主键往往是更合理的选择。

但是，如果是只有一个索引，且该索引必须是唯一索引的场景中，可以直接将该索引设置为主键。因为如果再引入一个自增主键，每次查询时就需要搜索两棵树，效率更低。


**References**
[1\] https://www.cnblogs.com/nullzx/p/8729425.html
[2\] https://time.geekbang.org/column/intro/139
