@[TOC](MySQL实践篇：count这么慢，我该怎么办？)

在开发系统的时候，你可能经常需要计算一个表的行数，比如一个交易系统的所有变更记录总数。这时候你可能会想，一条 `select count(*) from t` 语句不就解决了吗？但是，你会发现随着系统中记录数越来越多，这条语句执行得也会越来越慢。

# count(*)的实现方式
在不同的 MySQL 引擎中，`count(*)` 有不同的实现方式。

 - MyISAM 把一个表的总行数存在了磁盘上，执行 `count(*)` 的时候会直接返回这个数，效率很高（假设没有 `WHERE` 过滤条件）；
 - 而 InnoDB 引擎就麻烦了，它执行 `count(*)` 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。
 
那为什么 InnoDB 不跟 MyISAM 一样，也把数字存起来呢？这是因为即使是在同一个时刻的多个查询，由于多版本并发控制（**MVCC**）的原因，InnoDB 表“应该返回多少行”也是不确定的。

假设表 t 中有10000条记录，现在打开三个并行的会话并进行如下操作：

>图 1
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/c2f2dd92c72f1f226a77341facd84196.png#pic_center)

可以看到，在最后一个时刻，三个会话 A、B、C 会同时查询表 t 的总行数，但拿到的结果却不同。

这与 InnoDB 的事务设计有关系，**可重复读**是它默认的隔离级别，在代码上就是通过多版本并发控制，也就是 MVCC 来实现的。每一行记录都要判断自己是否对这个会话可见，因此对于 `count(*)` 请求来说，InnoDB 只好把数据一行一行地读出依次判断，可见的行才能够用于计算“基于这个查询”的表的总行数。

InnoDB 在执行 `count(*)` 操作的时候也做了优化。InnoDB 是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以，普通索引树比主键索引树小很多。对于 `count(*)` 这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，MySQL 优化器会找到最小的那棵树来遍历。在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。

此外， `show table status` 命令的输出结果里面也有一个 `TABLE_ROWS` 用于显示这个表当前有多少行。实际上，`TABLE_ROWS` 是通过索引统计的采样估算得来的，因此它也很不准，官方文档说误差可能达到 40% 到 50%。

**小结**

 - MyISAM 表虽然 `count(*)` 很快，但是不支持事务；
 - `show table status` 命令虽然返回很快，但是不准确；
 - InnoDB 表直接 `count(*)` 会**遍历全表**，虽然结果准确，但会导致性能问题。

如果现在有一个页面经常要显示交易系统的操作记录总数，到底应该怎么办呢？答案是，我们只能自己计数。

# 用缓存系统保存计数
对于更新很频繁的库来说，可以用缓存系统来支持。比如，可以用一个 Redis 服务来保存一个表的总行数。这个表每被插入一行 Redis 计数就加 1，每被删除一行 Redis 计数就减 1。这种方式下，读和更新操作都很快。

但是，这种方法存在的问题是，==缓存系统可能会丢失更新==。Redis 的数据不能永久地留在内存里，所以需要把这个值定期地持久化存储起来。但如果Redis 异常重启了，就可能丢失更新。解决的办法是，Redis 异常重启以后，到数据库里面单独执行一次 `count(*)` 获取真实的行数，再把这个值写回到 Redis 里就可以了。异常重启毕竟不是经常出现的情况，这一次全表扫描的成本，还是可以接受的。

但实际上，将计数保存在缓存系统中的方式，还不只是丢失更新的问题。即使 Redis 正常工作，==这个值还是逻辑上不精确的==。

考虑以下两种情形

>图 2
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/9b38752e1ffee37fc6732f7a8dab1a5a.png#pic_center)

>图 3
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/7e8e827ad9a6a9534a774151a0f8f57f.png#pic_center)

在并发系统里面，我们是无法精确控制不同线程的执行时刻的，因为存在图中的这种操作序列，所以，我们说即使 Redis 正常工作，这个计数值还是逻辑上不精确的。


# 在数据库保存计数
如果我们把这个计数直接放到数据库里单独的一张计数表 C 中，又会怎么样呢？

首先，这解决了崩溃丢失的问题，InnoDB 是支持崩溃恢复不丢数据的。至于计数不精确的问题，我们可以利用事务来解决。

>图 4
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/aa1fc6af7676a015434e099ccd8f4700.png#pic_center)




# 不同的 count 用法
首先，`count()` 是一个聚合函数，对于返回的结果集，一行行地判断，如果 **count 函数的参数不是 NULL**，累计值就加 1，否则不加。最后返回累计值。所以，`count(*)`、`count(主键 id)` 和 `count(1)` 都表示返回满足条件的结果集的**总行数**；而 `count(字段)`，则表示返回满足条件的数据行里面，参数“**字段**”（field）不为 NULL 的总个数。

对于 `count(主键 id)` 来说，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。对于 `count(1)` 来说，InnoDB 引擎==遍历整张表，但不取值==。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。

单看这两个用法的差别的话，你能对比出来，`count(1)` 执行得要比 `count(主键 id)` 快。因为从引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作。

对于 `count(字段) `来说：如果这个“字段”是定义为 `not null` 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；如果这个“字段”定义允许为 `null`，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。

但是 `count(*)` 是例外，并不会把全部字段取出来，而是专门做了优化，不取值。`count(*)` 肯定不是 null，按行累加。

所以结论是：按照效率排序的话，`count(字段) < count(主键 id) < count(1) ≈ count(*)`，所以建议尽量使用 `count(*)`。


