@[TOC](MySQL锁：全局锁和表锁)

根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类。

# 全局锁
全局锁就是对整个数据库实例加锁。MySQL加全局读锁的命令是 flush tables with read lock (**FTWRL**)。当你需要让整个库处于**只读**状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。

全局锁的典型使用场景是，做全库逻辑备份。也就是把整库每个表都 select 出来存成文本。

```sql
mysql> FLUSH TABLES WITH READ LOCK;
#全库逻辑备份
mysql> UNLOCK TABLES; 
```

全局锁的风险在于：

 - 如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；
 - 如果在从库上备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟。

MySQL官方自带的逻辑备份工具是 **mysqldump**。当 mysqldump 使用参数 `--single-transaction` 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于**多版本并发控制**（MVCC）的支持，这个过程中数据是可以正常更新的。但是，single-transaction 方法只适用于所有的表使用事务引擎的库，比如 MyISAM 引擎就不支持。

另一种设置全库只读的方法是使用命令 `set global readonly=true`。不建议使用此方法，原因在于：

 - 有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库；
 - 在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会**自动释放**这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。

# 表级锁
MySQL里表级别的锁可以分为**表锁**（table lock）和**元数据锁**（metadata lock, **MDL**）。

## 表锁
表锁一般是在数据库引擎不支持行锁的时候才会被用到的。表锁的语法是 `lock tables ... read/write`。

```sql
mysql> LOCK TABLES table_1 READ;  #读锁
mysql> UNLOCK TABLES;
mysql> LOCK TABLES table_2 WRITE;  #写锁
mysql> UNLOCK TABLES;
```

当线程 A 对表 table_1 加**读锁**时，线程A和其他线程都能读 table_1（读锁是共享锁），但都不能写 table_1；当线程 A 对表 table_2 加**写锁**时，只有线程 A 可以读写 table_2，其他线程既不能读也不能写 table_2（写锁是排他锁）。

## 元数据锁
MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是保证读写的正确性（不会因表结构发生变化而受到影响）。当对一个表做**增删改查**操作的时候，加 **MDL读锁**；当要对表做**结构变更**操作的时候，加 **MDL写锁**。

 - MDL读锁之间不互斥，因此可以有多个线程同时对一张表增删改查（即 **DML** 和 **DQL** 操作）；
 - MDL读写锁之间、MDL写锁之间是**互斥**的，用来保证变更表结构操作的安全性（即 **DDL** 操作）。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。

MDL会直到事务提交才释放，在做表结构变更的时候，一定要小心不要导致锁住线上查询和更新。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210316144825984.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlYmFzdGllbjIz,size_16,color_FFFFFF,t_70#pic_center)
在上图中，session A先启动，会对表 t 加一个MDL读锁。之后 session B启动，也会对表 t 增加一个MDL读锁。接着 session C 会被 blocked，是因为 session A 的 MDL 读锁还没有释放，而 session C 需要 MDL 写锁，因此只能被阻塞。而且之后所有要在表 t 上新申请 MDL 读锁的请求也会被 session C 阻塞，等于这个表现在完全不可读写了。


# 行锁
MySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。

## 两阶段锁
在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到**事务结束时**才释放。这个就是两阶段锁协议。如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放，以减少阻塞时间。

## 死锁和死锁检测
当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为**死锁**。如图，事务 A 在等待事务 B 释放 id=2 的行锁，而事务 B 在等待事务 A 释放 id=1 的行锁。 事务 A 和事务 B 在互相等待对方的资源释放，就是进入了死锁状态。

![死锁](https://img-blog.csdnimg.cn/20210317151453475.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlYmFzdGllbjIz,size_16,color_FFFFFF,t_70#pic_center)

出现死锁时，有两种对策：

 1. 直接进入等待，直到超时。这个超时时间可以通过参数 `innodb_lock_wait_timeout` 来设置；
 2. 发起**死锁检测**，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 `innodb_deadlock_detect` 设置为 on，表示开启这个逻辑。

在 InnoDB 中，`innodb_lock_wait_timeout` 的默认值是 **50s**。对于在线服务来说，这个等待时间往往是无法接受的。但是，超时时间设置太短的话（比如1s），会出现很多误伤，因为有可能只是简单的锁等待。所以，正常情况下还是要采用第二种策略，即：主动死锁检测，而且 `innodb_deadlock_detect` 的默认值本身就是 **on**。

主动死锁检测在发生死锁的时候，能够快速发现并进行处理，但是它也是有额外负担的。每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。

每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 **O(n)** 的操作。假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是 100 万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的 CPU 资源。因此，你就会看到 CPU 利用率很高，但是每秒却执行不了几个事务的“奇怪”现象。

为了解决由这种热点行更新导致的性能问题，即死锁检测要耗费大量的 CPU 资源，有三种对策：

 1. 如果能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。但是这种操作本身带有一定的风险。关掉死锁检测意味着可能会出现大量的超时，这是业务有损的。
 2. 另一种对策是**控制并发度**。这个并发控制要做在数据库服务端。可以考虑在中间件实现；如果有能修改 MySQL 源码的人，也可以做在 MySQL 里面。基本思路就是，对于相同行的更新，在进入引擎之前排队。
 3. 最后，也可以从设计上优化这个问题，比如通过将一行改成逻辑上的多行来减少锁冲突。

References
[1\] https://time.geekbang.org/column/intro/139
[2\] http://www.zzvips.com/article/126261.html

