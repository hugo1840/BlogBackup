@[TOC](Oracle数据库存储结构：逻辑存储结构（二）)

# 区（Extent）
区是由**逻辑上相邻**（logically contiguous）的数据块组成的数据库存储单元。数据块在物理层面上可以分散于磁盘中，例如RAID条带化（striping）、以及考虑到文件系统的实现。

## 区的分配
默认地，在创建段时，数据库会为每个被创建的数据段（data segment）分配一个初始的区（initial extent）。一个区始终存储在一个数据文件中（即不会跨数据文件）。即使数据段中没有存入数据，初始区中的数据块仍然会专门为该数据段保留。每个数据段的第一个数据块中都包含了一个存有该数据段中所有区的信息的目录。

图1展示了一个尚未存储数据的数据文件中的一个数据段及其初始区。

>**图1 数据段及其初始区**
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/f4f7270784a6e5c704b6c6a8321916bd.gif#pic_center)

如果初始区被填满了数据，在需要更多空间时，数据库会自动地为该数据段分配一个递增区（incremental extent）。区的分配算法取决于表空间是本地管理的还是数据字典管理的（此处请参考上一篇文章）。在本地管理的情况下，数据库会搜索数据文件的位图来寻找相邻的空闲数据块。一个数据段的所有区总是在同一个表空间中，但是可能位于不同的数据文件中。

图2说明了数据库可以在同一个表空间的任意数据文件中为一个数据段分配区。例如，一个数据段的初始区在 `users01.dbf` 文件中，但是第一个递增区位于 `users02.dbf` 中，而第二个递增区又回到了 `users01.dbf` 中。

>**图2 数据段的递增区**
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/cb5679d07e50c2ac3769b6df9e52df3f.gif#pic_center)

新分配的区里的数据块，尽管是空闲可用的，但并不意味着其中就没有还未删除的旧数据。在段空间自动管理（ASSM）模式下，Oracle数据库只有在开始使用一个新分配的区时，才会根据需要格式化其中的数据块。

## 区的释放
一般来说，用户段的区不会被释放给表空间重用，除非你执行 `DROP` 语句来移除对应的对象。比如，如果你删除（delete）了一个表中的所有行，数据库也不会回收对应的数据块来给同一个表空间中的其它对象使用。除了drop这个表以外，你也可以使用 `DBMS_SPACE_ADMIN` 包来移除数据段并释放其空间。

在某些情况下，你也可以手动释放区空间。Oracle Segment Advisor可以根据对象存储的碎片化程度来确定一个对象是否有可以回收的可用空间。下面的技巧可以用来释放区空间：

- 通过**在线段收缩**（online segment shrink）来回收数据段中的碎片空间。段收缩是一种在线的、原地的（in-place）操作。通常，数据压缩会带来更好的高速缓存使用效用，并且能减少在全表扫描中需要读取的数据块数目。
- 将一个未分区的表（non-partitioned table）或者表分区（table partition）中的数据移动到一个新的数据段中，并且还可选择移动到一个不同的表空间。
- 重建索引或者合并（coalesce）索引。
- 截断（**truncate**）一个表或者表集群，这会移除其中所有的行。默认Oracle数据库会释放这些被移除行的空间，除非存储参数 `MINEXTENTS` 另有说明。从Oracle 11.2.0.2开始，也可使用 `TRUNCATE` 并带上 `DROP ALL STORAGE` 选项来释放所有的数据段空间。
- 释放未使用的空间，即释放数据库高水位线一端未使用的段空间。

当有区空间被释放时，Oracle数据库会修改本地管理的表空间中数据文件中的位图信息，将被释放的区标明为可用空间。被释放的区空间原有的数据都将不再可访问。

## 区的存储参数
这些存储参数决定了Oracle数据库为每个数据段分配空间的方式。这些存储参数的设置具有如下的优先顺序：

1. 段存储子句（clause）
2. 表空间存储子句
3. 数据库默认值

一个本地管理的表空间可以拥有统一的区大小（extent size），也可以有可变的区大小。这由系统自动确定：

- 对于统一的区大小，你可以设置一个统一的值，也可以使用默认的 **1MB**。表空间里所有区的大小都将是这个值。本地管理的**临时**表空间只能使用这种分配方式。
- 对于自动分配的区，Oracle数据库自己决定区的最优大小。

# 段（Segment）
一个段是同一个表空间内存储了一个逻辑存储结构所有数据的区的集合。比如，一张表的**数据段**（data segment）中包含的所有区、或者一个表索引的**索引段**（index segment）中的所有区。Oracle数据库中的段空间可以自动或手动管理。以下的讨论默认数据库使用了段空间自动管理（ASSM）。

## 用户段
单个数据段存储一个**用户对象**（user object）的数据。用户段（user segment）的例子包括：

- 表、表分区、表集群；
- LOB或LOB分区；
- 索引或索引分区。

>**Lob**（Large Object）是Oracle专门用来处理半结构化和非结构化数据，它是一个大对象数据类型，可以存储超过4000字节的字符串、二进制数据。

每个未分区的对象以及对象分区都存储在自己的段中。比如，如果一个索引有五个分区，那么该索引数据会存储在五个段中。

**\#1 用户段创建**
默认地，当创建表、索引和分区时，数据库会创建 **deferred段**（deferred意为“延迟的”），仅更新数据库元数据。当用户向一张表或者一个分区插入第一行数据时，数据库才会为用户对象创建段。创建Deferred段可以避免不必要的资源开支。例如，应用安装时可能会创建成千上万的对象，占用大量的磁盘空间，但是其中许多对象根本不会被用到。

`DBMS_SPACE_ADMIN` 包管理空对象的段。你可以使用该 PL/SQL包来实现以下目的：

- 为还未创建段的空表或分区来手动materialize段；
- 从已经分配了一个空段的空表或分区中删除段。


## 临时段
在处理查询（query）时，Oracle数据库经常需要使用临时工作空间来完成SQL语句执行的中间阶段。典型的需要临时段（**temporary segment**）的操作包括**排序**（sorting）、**哈希**处理（hashing）、以及**位图合并**（merging bitmaps）。当**创建索引**时，Oracle数据库也会先将索引段放到临时段中，在索引创建完成后才会将其转入到永久段中。

如果一个操作可以在内存中进行，Oracle数据库就不会创建临时段。相反地，如果无法使用内存，数据库就会自动在磁盘中分配临时段。

**\#1 查询临时段的分配**
在用户会话中，Oracle数据库会按需为查询分配临时段，并在查询结束时释放临时段。对临时段的操作和修改一般不会被记录到在线redo log中，除非是对临时段的空间管理操作。

数据库在为用户分配的临时表空间中创建临时段。由于临时段的分配和释放非常频繁，最佳实践是为临时段创建至少一个表空间。数据库会在磁盘中分发I/O，避免因为临时段而碎片化（fragmenting）SYSTEM和其他表空间。

**\#2 临时表和索引的段分配**
Oracle数据库也会为临时表及其索引分配临时段。临时表中存储的数据只会存在一个事务或者一个会话的时间。每个会话只能访问分配给它自己的区（或临时段）。对于全局的临时表，数据库在插入第一行数据时为其分配段空间；对于私有的临时表，仅在需要的时候分配段空间。

## undo段
Oracle数据维护着事务的动作记录。这些记录共同被称为**undo数据**。Oracle数据库利用undo段来完成以下任务：

- 回滚活跃的（active）事务；
- 恢复终止的（terminated）事务；
- 提供读一致性（read consistency）；
- 进行一些逻辑闪回（flashback）操作。

Oracle数据库将undo数据存储在数据库中而不是外部日志文件中。Undo数据被存储在特定的blocks中。跟数据块类似，对这些存储了undo数据的blocks的修改操作都会生成redo记录。永久对象的undo数据存储在**undo表空间**中。Oracle数据库通过自动undo管理（automatic undo management mode）来管理undo表空间中的undo段空间。

Oracle数据库将undo数据分成两种流（streams）。**临时undo流**（temporary undo stream）仅仅包含了对临时对象修改而产生的undo记录；而**永久undo流**（permanent undo stream）则存储了对永久对象修改而产生的undo记录。数据库独立地管理临时undo流和永久undo流。这么做能够从以下方面减少存储消耗并提升性能：

- 可以根据工作负载分别为永久表和临时表配置最合适的永久表空间和临时表空间；
- 减少了写入到在线redo日志的redo记录量；
- 避免了备份临时的undo数据。


**\#1 undo段和事务** 
当有事务启动时，数据库会将事务分配给当前undo表空间中的一个undo段、一个事务表（transaction table）。如果数据库实例没有undo表空间（非常罕见的情况），该事务就会被分配给系统undo段。

多个活跃的事务可以并发地写入同一个undo段或者多个不同的undo段。一个undo段中的所有区组成了一个环。事务写入其中的一个undo区，然后循环写入下一个区。

>**图3 undo段循环写**
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/7b80540cd091d865755c5645efb0500f.gif#pic_center)

在任意一个给定时刻，同一个事务只能按顺序写入undo段中的一个区。这个区被称为该事务的当前区（**current extent**）。多个活跃事务可以同时写入同一个当前区或者不同的当前区。图3中，事务T1和T2同时写入了E3区。在同一个undo区中，同一个数据块只能包含一个事务的数据。

随着当前undo区被写满，接下来需要空间的事务会检查下一个区是否可用。如果下一个区没有包含活跃事务的数据，那么这个区就会成为当前区。所有需要空间的事务就会将数据写入新的当前区。如果下一个区包含了活跃事务的数据，那么数据库就必须分配一个新的区。图4展示了这种情况：当事务T1和T2写满E4后，由于E1包含活跃的undo记录，数据库分配了一个新的E5区。

>**图4 undo段分配新的区**
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/74c659635805691b4485f9504a81c963.gif#pic_center)


**\#2 事务回滚**
当执行 `ROLLBACK` 命令时，数据库利用undo记录来回滚未提交事务对数据库的修改操作。

在数据库恢复中，数据库将在线重做日志应用到数据文件，并回滚所有未提交的更新操作。通过维护同时被一个用户访问和另一个用户更新的数据，undo记录提供了读一致性。

**\#3 临时undo段**
临时undo段是仅用于临时undo数据的一个可选的空间管理容器。修改临时表的undo记录是与特定会话相关的，同时也仅用于读一致性和事务回滚。在Oracle 12c之前，数据库总是把这些记录存储在在线redo日志中。（之后）由于对临时对象的修改不再记录到在线redo日志中，将对应的undo记录写到临时undo段中可以节省redo日志文件中的空间。数据库也不会将对undo或临时表的修改写入日志，从而提升了性能。

设置 `TEMP_UNDO_ENABLED=TRUE` 初始化参数可以使得临时表将undo数据存入临时undo段。数据库将从临时表空间中分配临时undo段。

## 段空间与高水位线
Oracle数据库通过追踪段空间中数据块的状态来管理空间。高水位线（High water mark, **HWM**）是段空间中的一条分界线，超出该分界线的数据块尚未格式化（unformatted）且从未被使用过。

**\#1 MSSM & HWM**
段空间手动管理（**MSSM**）利用空闲清单（free lists）来管理段空间。在创建表时，段里的所有块都未格式化。当有会话首次向表中插入行时，数据库会搜索空闲清单来寻找可用的数据块。如果未找到，数据库就会预格式化（preformat）一组数据块，并将它们添加到空闲清单中，然后再向数据块插入数据。==在MSSM模式下，一次全表扫描会读取高水位线以下的所有数据块==。

**\#2 ASSM & HWM**
段空间自动管理（**ASSM**）管理段空间的方式则不同。当有会话首次向表中插入行时，数据库会格式化单个位图块（bitmap block）而不是像MSSM一样预格式化一组数据块。位图会跟踪段空间中数据块的状态。数据库利用位图来找到可用的数据块，然后将其格式化并填入数据。ASSM在多个数据块中分散插入操作以避免并发事件。

ASSM段中的每个数据块都处于以下一种状态：

- 在HWM之上：数据块尚未格式化且从未被使用；
- 在HWM之下：数据块可以处于以下三种状态之一：
  * 已分配，但尚未格式化、也未被使用；
  * 已经格式化，且存有数据；
  * 已经格式化，且因为存储的数据被删除，目前是空的。

图5中，HWM以下数据块**已被分配**，HWM以上的数据块既未被分配，也未被格式化。低高水位线（**low HWM**）以下的所有数据块都**已格式化**，因为它们或是存有数据、或是曾经存过数据。

>**图5 HWM和low HWM**
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/aefdbcd76ad95947c8e1441e4badadbe.gif#pic_center)

图6中，数据库选择了HWM和low HWM之间的一个数据块写入数据。数据库可以选取HWM和low HWM之间的任意一个数据块、或者low HWM以下任意一个还有可用空间的数据块。被选取的数据块两侧相邻的块可能都未格式化。

>**图6 HWM和low HWM之间**
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/568239121d39ecc4545c50ff83450e95.gif#pic_center)

Low HWM在**全表扫描**中很重要。由于HWM之下的数据块只有在被使用时才会格式化，因此会存在尚未格式化的块。数据库会读取位图块来获取low HWM的位置。==数据库会读取 low HWM 以下的所有数据块，同时会读取 low HWM 和 HWM 之间已经格式化的数据块==。

当HWM和low HWM之间的数据块都填满数据后，HWM上移，而low HWM会移动到HWM之前的位置。随着新数据的插入，HWM间歇地持续上移，而low HWM也随之移动。除非手动重建、截断（truncate）、或者缩小数据库对象，HWM永远不会回撤下移。

# 表空间
表空间（tablespace）是段的逻辑存储容器。在物理层面上，表空间将数据存储在一个或多个数据文件（data files）或临时文件（temp files）中。数据库必须有 `SYSTEM` 和 `SYSAUX` 表空间。

>表空间的内容请参考：Oracle数据库存储结构：逻辑存储结构（三）


**References**
[1\] https://docs.oracle.com/en/database/oracle/oracle-database/19/cncpt/logical-storage-structures.html#GUID-13CE5EDA-8C66-4CA0-87B5-4069215A368D
