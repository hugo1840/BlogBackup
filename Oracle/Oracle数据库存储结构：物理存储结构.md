@[TOC](Oracle数据库存储结构：物理存储结构)

本文所讨论的内容涉及的数据库版本为 Oracle 19c。

# 物理存储结构简介
Oracle的物理存储结构与逻辑存储结构是分离的，因此你可以在不影响逻辑结构访问的情况下对物理存储结构进行管理。Oracle数据库可以看作是持久化存储上保存有数据的文件集合。当你执行 `CREATE DATABASE` 时，会生成以下数据库文件：

- 数据文件和临时文件：数据文件（**data file**）是Oracle数据库在持久化存储中生成的物理文件，其中包含有表、索引等数据结构。临时文件（**temp file**）是属于临时表空间的数据文件。Oracle会以其他软件无法读取的专有格式向这些文件写入数据。
- 控制文件（**control file**）：是追踪数据库物理组成的二进制文件。没有控制文件数据库就无法启动。
- 在线重做日志（**online redo log**）：是记录对数据库操作的日志文件。

数据库实例（**database instance**）是管理数据库文件的内存结构的集合。下图展示了数据库实例与它管理的文件之间的关系。

> **图1 数据库实例与数据库文件**
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/f2af1b3108f2a6cf1e2ab9699b13b429.gif#pic_center)

## 数据库文件的存储机制
Oracle数据库常见的管理物理文件存储的机制包括：

- **Oracle自动存储管理**（Automatic Storage Management, ASM）：Oracle ASM 是专门为 Oracle 数据库设计的一种文件系统。
- **操作系统的文件系统**（Operating system file system）：大多数 Oracle 数据将文件存储在文件系统中。所有的操作系统都有在文件系统中给文件分配和释放磁盘空间的文件管理器。文件系统通常建立在逻辑卷管理器（Logical volume manager, LVM）创建的逻辑卷上。
- **集群文件系统**（Cluster file system）：集群文件系统是一个分布式的文件系统，通常用于对客户提供高性能服务的服务器集群。集群中的一个节点失败不会使整个文件系统不可用。

在实际应用中，Oracle数据库可以组合使用以上存储机制。比如，可以将控制文件和在线 redo 日志存储在传统的文件系统中，用户的某些数据文件存储在裸分区（**raw partitions**）中，其他的数据文件存储在 ASM 中，而归档的 redo 日志文件存储到集群文件系统中。

## Oracle ASM
自动存储管理是一个高性能、易于管理的 Oracle 数据库文件存储解决方案。Oracle ASM 也是一个专门为 Oracle 数据库提供文件系统的卷管理器（volume manager）。相对于传统的文件系统和存储管理器，ASM 具有如下优点：

- 简化了存储相关的任务，例如创建和布局（lay out）数据库、管理磁盘空间；
- 在物理磁盘上分布数据，解决了热点（hot spots）问题，同时提供了一致的性能；
- 在存储结构发生变化后自动再平衡（rebalance）数据。

要使用Oracle ASM，你需要为Oracle数据库分配已分区的磁盘，并具有条带化（**Striping**）和镜像（**Mirroring**）的首选项。Oracle ASM 管理磁盘空间，在所有可用资源之间分配 I/O 负载，以优化性能，同时消除了手动 I/O 调整的需要。

**ASM 存储结构**
Oracle 可以将数据文件存储为 ASM 磁盘组（**ASM disk group**）中的一个 ASM 文件（也可以存储其他类型的数据库文件）。下图展示了使用 ASM 的 Oracle数据库中的存储关系。

>**图2 Oracle ASM 组成**
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/78166144172e89ab5cb814764bcc2431.gif#pic_center)

其中出现了以下重要概念：

- **ASM磁盘**：是分配给 ASM 磁盘组的存储设备。ASM 磁盘可以是一个物理磁盘，也可以是一个分区、存储阵列（storage array）中的一个逻辑单元号（Logical unit number, LUN）、一个逻辑卷、或者一个网络附属文件（network-attached file）。
- **ASM磁盘组**：是 ASM 作为一个逻辑单元来管理的一个 ASM 磁盘的集合。在磁盘组内，Oracle ASM 会为数据库文件暴露一个文件系统接口。磁盘组内存储的文件内容是均匀分布或者条带化的，以解决热点问题并提供一致的性能。
- **ASM文件**：是存储在磁盘组中的文件。可以将 Oracle 中的数据文件、控制文件、在线重做日志等其它类型的文件存储为 ASM 文件。ASM 文件名以加号和ASM 磁盘组文件名开头，例如 `+DISKGROUP/DB_INSTANCE/DATAFILE/tablepsace.256.167523`。
- **ASM区**（ASM extents）：是 ASM 文件的一部分。一个 ASM 文件由一个或多个 ASM 区组成。每个 ASM 区由一个磁盘上的一个或多个分配单元组成。（注意：这里的ASM 区与逻辑存储结构中的区不一样。）
- **ASM分配单元**（allocation units）：是 ASM 磁盘组内的基本分配单元。分配单元是 Oracle ASM 分配的最小的邻近的磁盘空间。一个或多个分配单元组成一个 ASM区。


**ASM 实例**
ASM 实例是仅用于管理 ASM 磁盘的特殊 Oracle 实例。Oracle 数据库实例和 ASM 实例都需要共享访问 ASM磁盘组中的磁盘。ASM 实例管理磁盘组的元数据，并向数据库实例提供文件布局信息。数据库实例**不**需要经过 ASM 实例就能直接向 ASM 磁盘进行 I/O 操作。

Oracle 使用相同的技术建立 ASM 实例与数据库实例。例如，与数据库实例类似，ASM 实例也有一个系统全局区（System global area, **SGA**）和后台进程。但是，ASM 实例不能挂载数据库，功能也比数据库实例少很多。

下图展示了一个 ASM 实例 和两个数据库实例组成的单点架构。

>**图3 Oracle ASM实例和数据库实例**
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/5c930eecd39bb77d9b83da99bd967c91.gif#pic_center)

## Oracle管理的文件 vs 用户管理的文件
Oracle 管理的文件（**Oracle managed files**）是一个允许你使用数据库对象（而不是文件名）来说明操作的文件命名策略。例如，你可以创建一个表空间而无需注明它的数据文件。Oracle 管理的文件使得数据库管理员无需直接管理数据库中的操作系统文件。Oracle ASM 需要使用 Oracle 管理的文件。

另一方面，通过用户管理的文件（**user-managed files**），你可以直接管理数据库中的操作系统文件。你需要自主决定文件结构和命名。比如，创建一个表空间时指定其他名字和其中数据文件的路径。

# 数据文件（data files）
在操作系统层面，Oracle 数据库将数据存储在数据文件中。Oracle 数据库必须至少有一个数据文件。

## 数据文件的用途
每个未分区的 schema 对象（比如表、索引）、对象的每个分区都存储在自己的段（segment）中。每个段都只属于一个表空间（tablespace）。表空间和数据文件存在以下重要区别：

- 每个表空间由一个或多个数据文件组成；
- 一个数据库的所有数据都存储在数据库表空间的数据文件中；
- 一个段可以跨越一个或多个数据文件，但是不能跨越多个表空间；
- 一个Oracle数据库必须有 **SYSTEM** 和 **SYSAUX** 这两个表空间。在数据库创建时，Oracle 会自动为 SYSTEM 表空间分配第一批数据文件。SYSTEM 表空间中存有**数据字典**（data dictionary），即包含数据库元数据的表的一个集合。通常，Oracle 数据库还会有一个 **undo 表空**间和一个临时表空间（一般命名为 **TEMP**）。

下图展示了表空间、数据文件和段之间的关系。

>**图4 数据文件和表空间**
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/4c856bcd90d1c69edbe98a1cbfeac167.gif#pic_center)


>schema对象：https://docs.oracle.com/en/database/oracle/oracle-database/19/cncpt/tables-and-table-clusters.html#GUID-72E247B5-F39A-47F1-9445-72D9221F57E3

## 永久数据文件 vs 临时数据文件
**永久表空间**（permanent tablespace）包含有持久化的 schema 对象，存储在永久数据文件中。

**临时表空间**（temporary tablespace）中的 schema 对象只存在于一个 session 中。在本地管理的临时表空间包含有临时文件（temp files），用于存储哈希、排序等操作中的数据。当内存空间不够时，临时文件也会用来存储查询操作的结果集数据。

临时文件与永久数据文件相似，但存在以下区别：

- 永久数据库对象，比如表，不会存储在临时文件中；
- 临时文件一直被设定为 **NOLOGGING** 模式，即不会产生 redo日志。介质恢复过程中也不会识别临时文件；
- 临时文件不能被设置为只读；
- 不能使用 **ALTER DATBASE** 命令来创建临时文件；
- 当你创建或者改变临时文件的大小时，Oracle 并不会保证会给临时文件分配到指定文件大小的磁盘空间。在 Linux 和 Unix 操作系统中，临时文件会被创建为稀疏文件（sparse files）。即只有当数据块被首次访问时才会给临时文件分配磁盘空间，而不是在创建或者 resize 临时文件时就分配。
- 临时文件的信息可以在数据字典视图 `DBA_TEMP_FILES` 和 动态性能视图 `V$TEMPFILE` 中查看，但无法在 `DBA_DATA_FILES` 或 `V$DATAFILE` 视图中看到。

## 在线数据文件 vs 离线数据文件
数据文件有在线（可用）和离线（不可用）两种状态。数据库无法访问离线的数据文件。当要进行离线备份或者发生数据块损坏时，就可以将数据文件离线。如果数据库无法向一个数据文件写入数据，就会自动将该数据文件离线。

与数据文件类似，表空间也有在线和离线两种状态。如果将一个在线表空间中的一个数据文件离线，该表空间本身仍然会保持在线状态。当我们将一个表空间离线，该表空间内的所有数据文件都会暂时不可用。

从 Oracle 12c 开始，在数据库打开时，可以使用 `ALTER DATABASE MOVE DATAFILE` 语句将一个在线的数据文件从所在的物理文件迁移到另一个物理文件。该功能可以在以下场景中使用：

- 将表空间从一种存储中迁移到另一种存储中；
- 将很少被访问的数据文件迁移到开销低的存储中；
- 将表空间设置为只读后，将其中的数据文件迁移到 write-once 存储中，比如 WORM （write once read many）驱动（一次性写入后不可删除和修改）；
- 将数据库迁移到 Oracle ASM。

## 数据文件结构
在创建数据文件时，除了分配指定的磁盘空间以外，还会加上数据文件 **header** 的大小。数据文件 header 中包含有该数据文件的元数据，比如数据文件大小和**检查点 SCN**（checkpoint system change number, Checkpoint SCN）。每个数据文件 header 都包含一个**绝对文件编号**（用于在数据库中唯一标识该数据文件）和一个**相对文件编号**（用于在表空间中唯一标识该数据文件）。

创建数据文件时，分配的磁盘空间会被格式化但是尚未存储用户数据。这部分磁盘空间会被保留给相关表空间中将来存储数据的 segment。随着表空间的数据增长，Oracle 会将数据文件中的剩余空间用来给 segment 分配区（extent）。

下图展示了数据文件中的不同空间。

>**图5 数据文件中的空间**
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/1348be5247e2d5d81c2ceef8d811d1ae.gif#pic_center)


# 控制文件（control files）
控制文件是仅与一个数据库有关的二进制文件。每个 Oracle 数据库都有一个唯一的控制文件，但是允许存在多个相同的控制文件拷贝。

## 控制文件的用途
Oracle 数据库使用控制文件来定位数据库文件、管理数据库状态。

控制文件中包含如下信息：

- 数据库的名称、数据唯一识别ID（database unique identifier, **DBID**）；
- 创建数据库的时间戳；
- 数据文件、在线 redo log 文件、归档 redo log 文件的相关信息；
- 表空间的信息；
- RMAN 的备份信息。

控制文件有如下重要用途：

- 控制文件包含有数据文件和在线重做日志文件的信息，是**打开数据库所需的**。控制文件还会跟踪记录更新**数据库的结构变化**（比如新建、重命名、删除数据文件）。
- 控制文件包含有**数据库关闭时必须可访问的元数据**。比如，用于恢复（recover）数据库的信息。

在数据库使用过程中，Oracle 持续地读写控制文件。在恢复数据库时，也需要从控制文件中读取所有数据文件的名称。在添加、删除、重命名数据文件时，控制文件中的信息也会更新。

## 控制文件复用
Oracle 允许同时打开多个相同的控制文件，写入同一个数据库。通过在不同的磁盘上复用控制文件，可以达到冗余状态以避免单点故障。

如果一个控制文件无法使用，数据库实例在试图访问受损的控制文件时会失败。当存在当前控制文件的拷贝时，你可以重新挂载数据库，不使用介质恢复（**media recovery**）打开数据库。如果一个数据库的所有控制文件都丢失了，数据库实例会失败，这时就需要进行介质恢复。

## 控制文件结构
数据库信息存储在控制文件的不同部分（section）。比如，控制文件中的一部分用于跟踪数据文件信息，其中的每条记录（record）对应一个数据文件。控制文件的每个部分都存储在多个逻辑控制文件块（block）中。每条记录可以跨多个块。

控制文件中包含以下类型的记录：

- 循环复用记录（**Circular reuse records**）：包含非关键信息，在有需要时**可以被覆写**（overwritten）。比如归档 redo log 文件和 RMAN 备份相关的记录。
- 非循环复用记录（**Noncircular reuse records**）：包含很少改变的关键信息，**不能被覆写**。比如表空间、数据文件、在线 redo log 日志文件、redo 线程等。除非相关的对象被从表空间中删除，Oracle 数据库从不复用这些记录。

可以通过动态视图查看控制文件中的信息。比如，查看 `V$DATABASE` 视图获取数据库的名称和 DBID。但是，只有数据库本身才能修改控制文件中的信息。

读写控制文件 blocks 的方式也与读写普通数据块的方式不同。Oracle 数据库直接从磁盘向程序缓存区（Program global area, **PGA**）读写控制文件。每个进程都会为控制文件块分配一定大小的 PGA 内存。

# 联机重做日志（online redo log）
联机重做日志是数据库恢复中至关重要的存储结构，由两个或多个预分配的文件组成，其中记录了对数据文件所做的修改。

## 联机重做日志的用途
数据库维护联机重做日志以抵御数据丢失。如果数据库实例失败了，联机重做日志可以用来恢复已提交但是还未写入数据文件的数据。

服务器进程将每个事务同步写入redo日志缓冲区（redo log buffer），随后 **LGWR**（log writer process）进程将日志缓冲区的内容写入联机重做日志。联机重做日志的内容包括了未提交的事物、schema、对象管理语句（object management statements）。

当数据库修改 undo段（undo segments）时，所做的修改会被写入联机重做日志。因此，联机重做日志总会包含永久对象的 undo数据。

Oracle 数据库仅在**恢复**中会用到联机重做日志。但是，数据库管理员可以使用 Oracle LogMiner 来查看联机重做日志文件，以了解数据库的历史活动信息。

## 怎么写联机重做日志
数据库实例的联机重做日志被称为redo线程（redo thread）。

在单实例架构中，只有一个redo线程。在 Oracle RAC（Real Application Clusters）集群中，多个实例同时访问一个数据库，其中每个实例都有自己的redo线程。

一个联机重做日志由**两个或多个**联机重做日志文件组成。Oracle 数据库需要至少两个文件来保证始终有一个联机重做日志文件可写，以防另一个文件正在被清除或者归档中。

**联机重做日志切换**
Oracle 数据库一次只使用一个联机重做日志文件来存储从redo日志缓冲区写入的记录。日志写进程（**LGWR**）正在写入的联机重做日志文件被称为当前联机重做日志文件（current online redo log file）。

当数据库停止向一个联机重做日志文件写入，而开始向另一个文件写入时，就会发生日志切换（**log switch**）。日志切换通常发生在当前联机重做日志文件写满但是仍需要继续写的时候。你也可以人为设置日志切换的频率，而不考虑日志是否已经写满。

LGWR 日志写进程写联机重做日志文件是**循环写**的（circularly）。当最后一个可用的联机重做日志文件写满后，LGWR 进程就会从头开始写第一个日志文件。

>**图6 联机重做日志文件循环写**
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/ca64d11eaa1b3c066da779d4a8e8a5f5.gif#pic_center)

从图6可以看出，在发生日志切换时，数据库会为联机重做日志分配一个新的**日志序列号**（log sequence number）。已经写满的联机重做日志文件是否可以取决于归档模式：

- 如果禁用了归档模式（**NOARCHIVELOG**），写满的联机重做日志文件在经过检查点（checkpoint）被 **DBW**（database writer）写入磁盘后可用。
- 如果启用了归档模式（**ARCHIVELOG**），写满的联机重做日志文件在被写入数据文件并归档后对 log writer 可用。

有时log writer会被禁止复用某个联机重做日志文件。需要利用正在使用的联机重做日志文件（active online redo log file）进行实例恢复。

**联机重做日志文件的多副本**
Oracle 数据库会在不同的位置自动维护两个或多个相同的联机重做日志副本。一个**联机重做日志组**（online redo log group）由一个联机日志文件和它的冗余副本组成。每个日志组都有一个编号。维护联机重做日志组可以防止重做日志丢失。理想情况下，一个日志组的所有成员应该分布在不同的磁盘上。

图7中，A_LOG1 和 B_LOG1 是组1的相同成员，A_LOG2 和 B_LOG2 是组2的相同成员。同一个日志组内的成员大小都必须相等。LGWR 进程并发地写入组1，然后并发地写入组2，再然后并发写入组1，如此交替。LGWR 不会同时并发写入不同日志组的成员。


>**图7 联机重做日志的多个副本**
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/828d12895614cfb01f8f5d11978c2f12.gif#pic_center)


**归档redo日志文件**
归档重做日志文件是一个联机重做日志组中一个已经写满的日志文件的离线副本。它不是数据库的组成部分。

归档日志重做文件是备份和恢复策略的关键部分。你可以使用归档日志重做文件来：

- 恢复数据库备份；
- 更新备库（standby database）；
- 通过 LogMiner 获取数据库的历史信息。

可以通过自动归档或者手动归档来生成归档重做日志文件。但仅能够在归档模式（**ARCHIVELOG**）下进行。如果开启了自动归档，**archiver process (ARCn)** 会自动归档联机重做日志组中的一个日志文件。参考图7，如果 A_LOG1 已损坏，该进程就会归档 B_LOG1。归档重做日志包含了从启用归档以来每个重做日志组的一个副本。

## 联机重做日志的结构
联机重做日志包含redo记录（redo record）。一条redo记录由一组修改向量（change vectors）组成，其中每个向量都描述了对数据块所做的一次修改。

redo记录中包括以下与数据块修改相关的元数据：

- 修改的 SCN 和时间戳；
- 执行修改操作的事务ID；
- 事务提交的 SCN 和时间戳（如果已提交）；
- 执行修改的操作类型；
- 被修改的数据段的名称和类型。



References
[1\] https://docs.oracle.com/en/database/oracle/oracle-database/19/cncpt/physical-storage-structures.html#GUID-E76E1A63-DFC5-42C5-AFD8-28753428C577


